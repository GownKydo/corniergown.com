[{"content":"\n¡Hola a todos! En esta ocasión, vamos a abordar el fascinante tema de las tareas cron, como se indica en el título. Para comenzar, vamos a adentrarnos en el concepto de qué es una tarea cron y su importancia en la administración de sistemas\n¿Qué es una tarea cron? Cron es un demonio que ejecuta comandos en horarios definidos por el administrador. Está diseñado para simplificar tareas repetitivas que, de otro modo, tendrían que ejecutarse manualmente.\nCada tarea gestionada por cron es conocida como un \u0026ldquo;cron job\u0026rdquo;, la cual se especifica en una tabla llamada \u0026ldquo;cron tab\u0026rdquo;. Cada línea en la crontab representa una tarea y consta de una combinación de hora y fecha seguida del comando a ejecutar. Estas tareas pueden ejecutarse en segundo plano, permitiendo que los comandos se ejecuten automáticamente en el momento deseado por el administrador.\nLimitaciones de una tarea cron A pesar de sus beneficios cron tiene sus limitaciones.\nEjecucion en redes distribuidas: Cron no está diseñado para ejecutarse en una red distribuida, lo que significa que no puede coordinar tareas entre varios servidores o terminales de red. Esta limitación puede ser un inconveniente en entornos de alta disponibilidad y sistemas distribuidos. Capacidades avanzadas de gestion: Aunque cron es una herramienta poderosa y sencilla, no cuenta con capacidades avanzadas para la gestión de tareas, como el manejo de dependencias entre tareas o la detección y recuperación automática de fallos. Esto puede limitar su uso en sistemas más complejos donde estas características son esenciales. Estructura de una tarea cron Las tareas cron tienen la siguiente estrucutra, estan divididas en 5 grupos y dos mas que identifican que usuario esta ejecutando la tarea y el comando o script que se esta corriendo.\nminutes hours day month month day week user script/command 0-59 0-23 1-31 1-12 0-6 user /path/test.sh * * * * * Caracteres especiales:\nTambien tenemos los caracteres especiales, los cuales nos ayudar a facilitar la redaccion de las tareas o crear procesos mucho mas complejos y como tal mucho mas precisos.\nCaracter Definicion * Rellena un campo sin ningun valor especifico / Especificar un intervalo de tiempo , Seleccionar multiples valores - Especificar un rango especifico Una vez sabemos todo esto, ya podremos empezar a crear nuestras propias reglas. Pero es probable que, si queremos hacer alguna muy compleja, sea necesario tener algunos conocimientos de programación. Sobre todo, para comprender la estructura de cómo se va a ejecutar alguna tarea concreta. Y en caso de que falle, sabes donde se puede estar produciendo el problema en cuestión.\nPracticando con tareas cron Es importante mencionar que las pruebas de esta práctica se realizan en sistemas operativos basados en Arch. Por lo tanto, algunos comandos pueden diferir de aquellos utilizados en otros sistemas operativos basados en Debian o sistemas basados en RHE(red hat enterprise).\nPara empezar, debemos convertirnos en usuarios root para poder administrar las tareas cron. Una vez con permisos de root, navegamos a la ruta /etc/cron.d, donde se encuentran las tareas. Dentro del directorio, verificaremos el estado de nuestro demonio cron con el siguiente comando: systemctl status cronie. En sistemas basados en Debian, se debe cambiar la palabra cronie por cron, o de igual forma pueden usar el siguiente comando service cron status. Una vez escrito el comando, obtendremos el siguiente resultado:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ● cronie.service - Command Scheduler Loaded: loaded (/usr/lib/systemd/system/cronie.service; enabled; preset: disabled) Active: active (running) since Fri 2024-06-07 16:04:45 EST; 8s ago Main PID: 6880 (crond) Tasks: 1 (limit: 6988) Memory: 888.0K (peak: 1000.0K) CPU: 3ms CGroup: /system.slice/cronie.service └─6880 /usr/sbin/crond -n Jun 07 16:04:45 kinghost systemd[1]: Started Command Scheduler. Jun 07 16:04:45 kinghost crond[6880]: (CRON) STARTUP (1.7.2) Jun 07 16:04:45 kinghost crond[6880]: (CRON) INFO (Syslog will be used instead of sendmail.) Jun 07 16:04:45 kinghost crond[6880]: (CRON) INFO (RANDOM_DELAY will be scaled with factor 92% if used.) Jun 07 16:04:45 kinghost crond[6880]: (CRON) INFO (running with inotify support) Jun 07 16:04:45 kinghost crond[6880]: (CRON) bad command (/etc/cron.d/0hourly) Jun 07 16:04:45 kinghost crond[6880]: (CRON) INFO (@reboot jobs will be run at computer\u0026#39;s startup.) Aquí podemos notar que el servicio ya está activado. Si en tu sistema está desactivado, escribe el siguiente comando para activarlo: systemctl start cronie. En sistemas de debian tambien podemos usar esta alternativa service cron start. Posteriormente, vuelve a escribir el comando para verificar el estado de nuestro demonio cron y ya debería estar activo.\nCreando una tarea cron Ahora vamos a crear una tarea cron. Para este caso, dentro de la ruta en la que estamos que es /etc/cron.d, crearemos un archivo que puede llevar el nombre que desees. En mi caso, lo llamaré \u0026ldquo;tarea\u0026rdquo;. Escribiremos el siguiente comando para crear el archivo: touch tarea\nLuego, procedemos a abrirlo con el editor de texto de preferencia y una vez dentro, escribimos la estructura de una tarea cron, que está dividida en cinco campos como lo explique anteriormente, colocare los 5 campos con asteriscos, esto le indica a el servicio cron que quiero que se ejecute cada minuto. Esta seria la estructura de nuestro archivo:\n1 * * * * * root /home/gerardokydo/Desktop/file.sh Y como sabemos que este archivo \u0026ldquo;file.sh\u0026rdquo; no existe, vamos a crearlo. Nos dirigimos a la ruta \u0026ldquo;Desktop\u0026rdquo; de nuestro usuario normal y creamos el archivo usando el comando touch file.sh. Una vez que el archivo esté creado, le daremos permisos de ejecución con el siguiente comando: chmod +x file.sh. Luego procedemos a editarlo con nuestro editor preferido y escribimos la tarea que deseamos que realice. A modo de ejemplo, escribimos lo siguiente:\n1 2 3 4 #!/bin/bash sleep 10 rm -rf /tmp/* En este script, sleep 10 hace una pausa de 10 segundos y rm -rf /tmp/* borra todos los archivos en el directorio /tmp/. Guardamos el archivo y en este punto nuestro demonio cron debería estar ejecutándose correctamente.\nAbuso de tareas cron Es importante destacar que, en términos de seguridad, es crucial administrar adecuadamente el acceso al sistema cron. Cualquier usuario con permisos puede modificar su propio archivo crontab, lo que podría permitir la ejecución de comandos con privilegios de usuario. Por lo tanto, se recomienda limitar el acceso a cron solo a usuarios autorizados y revisar regularmente los archivos de crontab para evitar abusos o errores.\nA continuación, presentamos un ejemplo de abuso de tareas cron. Este ejemplo se realiza con fines educativos en un entorno controlado y sin afectar a nadie. La intención es demostrar cómo un uso indebido de cron puede comprometer la seguridad del sistema y cómo podemos prevenirlo mediante buenas prácticas.\nDeteccion de tareas cron Vamos a realizar una detección de tareas cron con el objetivo de buscar archivos en la raíz que puedan ser modificados por un usuario sin permisos de root. Esto se puede hacer de dos formas: manualmente mediante un script en bash, o utilizando una herramienta en Linux llamada pspy que está escrita en Go. Sin embargo, para entender mejor cómo detectar tareas cron, lo haremos de forma manual, lo que también nos ayudará a comprender la lógica subyacente.\nPara esta ocasión, vamos a utilizar el comando ps. Este comando, con ciertos parámetros, puede listar los comandos que se están ejecutando en tiempo real en el sistema, lo cual es muy útil para monitorear y detectar tareas cron. Además, utilizaremos el comando diff, que permite comparar dos archivos y mostrar sus diferencias. Esta combinación de herramientas nos ayudará a identificar cambios en los procesos y archivos del sistema. Si quieres saber mas acerca de los comandos y sus diferentes parametors les dejare al final del blog el manual page de cada uno de los comandos presentados en este post.\nContinuemos. Vamos a crear un archivo en nuestro escritorio con el siguiente comando: touch MonitorProcess.sh, le asignamos los permisos de ejecucion con el siguiente comando: chmod +x MonitorProcess.sh\nLuego, lo abrimos con el editor de texto de nuestra preferencia. Una vez dentro del archivo, escribimos el siguiente código:\n1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash old_process=$(ps -eo command) while true; do new_process=$(ps -eo command) diff_result=$(diff \u0026lt;(echo \u0026#34;$old_process\u0026#34;) \u0026lt;(echo \u0026#34;$new_process\u0026#34;)) echo \u0026#34;$diff_result\u0026#34; | grep \u0026#34;[\\\u0026gt;\\\u0026lt;]\u0026#34; | grep -v \u0026#34;kworker\u0026#34; old_process=$new_process done Una vez tengamos el codigo, vamos a repasar lo que hemos escrito:\nEmpezamos definiendo las cabeceras principales de nuestro codigo las cuales se identifican al inicio del mismo #!/bin/bash. Creamos una variable llamada \u0026ldquo;old_process\u0026rdquo; la cual va a guardar el output de nuestro comando ps -eo command. Si escribimos dicho comando desde nuestra terminal tendremos los procesos listados que se estan ejecutando en tiempo real. Creamos un bucle while infinito para ir actualizando los cambios de los procesos:\nDentro de este mismo bucle, creamos una variable llamada \u0026ldquo;new_process\u0026rdquo; la cual va a guardar los nuevos procesos que vayan apareciendo. Haciendo uso del comando diff creamos una nueva variable llamada \u0026ldquo;diff_result\u0026rdquo; que guardara el output del comando diff, a este comando le pasamos por parametros que evalue la diferencia de las variables \u0026ldquo;old_process\u0026rdquo; y \u0026ldquo;new_process\u0026rdquo; Posteriormente con el comando echo imprimimos el contenido de nuestra variable \u0026ldquo;diff_result\u0026rdquo; y con la ayuda del comando grep y el parametro -v filtramos los procesos que se cierran(\u0026lt;) y los que se abren(\u0026gt;) tambien filtramos por los procesos no deseados para que no los tome en cuenta, en mi caso todos aquellos que contiene la palabra \u0026ldquo;kworker\u0026rdquo; Y para concluir con el programa solo actualizamos nuestra variable \u0026ldquo;_old_process\u0026rdquo; igualadnola a nuestra variable \u0026ldquo;new_process\u0026rdquo;. Una vez que tengamos pasando este punto procedemos a correr el codigo y si esperan un tiempo podran notar que este estara listando los procesos que se estan ejecutando en tu sistema, esto va desde configuraciones que has hecho, aplicaciones abiertas, pero lo que nos va a importar es cuando aparezca algo relacionado a las tareas cron, por ejemplo lo siguiente:\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt; /usr/sbin/CROND -n \u0026lt; /bin/bash /home/gerardokydo/Desktop/file.sh \u0026lt; sleep 10 \u0026gt; (udev-worker) \u0026gt; /bin/sh /usr/bin/tlp auto \u0026gt; /usr/bin/perl /usr/share/tlp/tlp-readconfs --outfile /run/tlp/tlp-run.conf_tmp9CBkvC \u0026lt; /usr/bin/perl /usr/share/tlp/tlp-readconfs --outfile /run/tlp/tlp-run.conf_tmp9CBkvC \u0026gt; /bin/sh /usr/bin/tlp auto \u0026gt; cat /sys/class/power_supply/AC/online \u0026lt; /bin/sh /usr/bin/tlp auto \u0026lt; cat /sys/class/power_supply/AC/online \u0026lt; /bin/sh /usr/bin/tlp auto En mi caso, estos fueron los procesos que se listaron. El más relevante es el que se encuentra en las primeras líneas, donde podemos observar que se está ejecutando el demonio /usr/sbin/CROND -n y, a su vez, este ejecuta nuestro archivo \u0026ldquo;file.sh\u0026rdquo; almacenado en nuestro escritorio. Recordarán que este archivo hace un sleep 10 y posteriormente borra todo lo que está en la carpeta \u0026ldquo;/tmp/\u0026rdquo;.\nAhora, suponiendo que soy un atacante y noto este registro de procesos, investigaría más acerca de este fichero. Por lo tanto, escribiría el siguiente comando: ls -l /home/gerardokydo/Desktop/file.sh, lo que me dara el siguiente resultado:\n-rwxr-xrwx 1 gerardokydo gerardokydo 36 Jun 7 /home/gerardokydo/Desktop/file.sh\nPodemos observar que el propietario de este archivo ha habilitado la edición del archivo para el grupo \u0026ldquo;otros\u0026rdquo;. Esto significa que cualquier usuario en el sistema, independientemente de sus permisos, puede modificar este archivo. Como un usuario no privilegiado, puedo explotar esta configuración incorrecta de permisos para obtener privilegios elevados.\nPrimero, nos dirigimos a la ruta donde se encuentra el archivo. Dado que el archivo está siendo ejecutado por el usuario root, podemos cambiar su contenido para ejecutar comandos con privilegios de root. Esto es una vulnerabilidad seria que permite a un usuario no autorizado ejecutar acciones que normalmente estarían restringidas.\nPara modificar el contenido del archivo, utilizamos el siguiente comando:\n1 2 3 #!/bin/bash chmod 4775 /bin/bash Este script le asigna privilegios SUID a nuestra shell. El bit SUID permite que un archivo ejecutable se ejecute con los permisos del propietario del archivo, en este caso, root. Guardamos los cambios y salimos del archivo\nSi ahora escribimos ls -l /bin/bash, vamos a notar los privilegios, que se verían de la siguiente manera:\nrwxr-xr-x root root 1.1 MB Tue Jan 23 16:22:43 2024 /bin/bash\nPara monitorear los cambios en los permisos, utilizaremos el comando watch -n 1 ls -l /bin/bash, que actualizará la visualización cada segundo para mostrar el cambio en los permisos realizado por el script. Notaremos una letra \u0026rsquo;s\u0026rsquo; en los permisos:\n-rwsrwxr-x 1 root root 1112784 Jan 23 16:22 /bin/bash\nEsto sucede porque ahora SUID está activado. Esto nos permite ejecutar el binario con los permisos del propietario del archivo, en este caso, root.\nPara lanzar una shell con los privilegios del propietario (root), escribimos bash -p. Al presionar Enter, veremos que ahora somos usuario root. Podemos confirmarlo con el comando whoami.\nCon esto, hemos demostrado la importancia de una correcta configuración de las tareas cron. Si un atacante detecta archivos que se están ejecutando con permisos inadecuados, puede explotarlos para obtener privilegios elevados. Es crucial asegurar que los permisos estén correctamente configurados para prevenir intrusiones por parte de usuarios no autorizados.\nReferencias systemctl(1) — Linux manual page\nps(1) — Linux manual page.\ndiff(1) — Linux manual page\ngrep()1 — Linux manual page\nwatch(1) — Linux manual page\n","date":"2024-06-06T00:00:00Z","image":"http://localhost:1313/p/administracion-de-tareas-cron/CronJob_hub8427227b42a57f6a1892803f74cf60b_9574_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/administracion-de-tareas-cron/","title":"Administracion de tareas cron"},{"content":"En esta ocasión, como se menciona en el título, vamos a adentrarnos en el mundo de Linux. Este post está dirigido a aquellos que son nuevos en este sistema operativo, con el fin de ayudarles y guiarlos en el uso de la terminal sin temor a romper algo con algún comando.\nEste post será muy práctico, y para ello me guiaré de una página que considero increíble para aprender sobre los comandos en Linux. Para dar un breve resumen, esta página consiste en un juego de desafios en seguridad informatica. Tendrás que usar comandos en Linux para encontrar un archivo .txt donde se encuentra una contraseña para un usuario. A medida que subes de nivel, la dificultad aumenta. Para avanzar, deberás encontrar una \u0026ldquo;flag\u0026rdquo; para cada usuario, lo que representa los diferentes niveles y la flag la contraseña de acceso a los mismos.\nEspero que este post te sea de gran ayuda y te anime a explorar más sobre el fascinante mundo de Linux. ¡Empecemos!\nNos diriguimos a la siguiente pagina over the wire, nos llevara a esta pagina:\nLevel 0 -\u0026gt; Level 1 Aquí puedes leer más sobre lo que trata Bandit y en qué consiste. Nos dirigiremos al nivel 0, donde podemos ver las instrucciones para acceder como bandit0 y conectarnos al servidor mediante el comando SSH. Una vez que hemos leído las instrucciones, pasamos al siguiente nivel. En el siguiente nivel, podemos observar que nos dan las siguientes instrucciones.\nAquí ya podemos observar que las instrucciones nos indican que la contraseña para el siguiente nivel se encuentra en un archivo llamado \u0026ldquo;readme\u0026rdquo;, localizado en el directorio home de nuestro usuario \u0026ldquo;bandit0\u0026rdquo;. Vamos a confirmarlo. Como aún no me he conectado al juego, vamos a hacerlo.\nEn el nivel 0 se especifica que se debe usar ssh para acceder al servidor. Nos proporcionan un nombre de host, un puerto y la contraseña. La estructura del comando para acceder al nivel cero es la siguiente: ssh bandit0@bandit.labs.overthewire.org -p 2220. Si es nuestra primera vez usando el comando ssh, nos preguntará si estamos seguros de acceder al servidor. Entonces, escribimos \u0026lsquo;Y/y\u0026rsquo; o simplemente \u0026ldquo;yes\u0026rdquo;. A continuación, nos pedirá la contraseña del usuario bandit0, la cual es bandit0.\nUna vez dentro del servidor, comprobamos que somos el usuario bandit0 con el comando whoami. Este comando nos sirve para saber qué usuario está usando el sistema actualmente y, si todo está bien, podemos observar claramente que se trata del usuario \u0026ldquo;bandit0\u0026rdquo;. Posteriormente, escribimos el comando ls para listar el contenido de nuestro directorio home y ahí es donde se encuentra el archivo \u0026ldquo;readme\u0026rdquo; que contiene la contraseña para acceder a \u0026ldquo;bandit1\u0026rdquo;. Escribimos el comando cat readme para leer el contenido de este archivo y, como se puede observar, esa es la contraseña para el siguiente nivel, la copiamos en nuestro portapapeles y del servidor con el comando exit\nLevel 1 -\u0026gt; Level 2 Para el siguiente nivel, vamos a acceder como bandit1. Vamos a usar el mismo comando que usamos anteriormente con bandit0, pero cambiando el usuario. El comando es el siguiente: ssh bandit1@bandit.labs.overthewire.org -p 2220. La única diferencia será el número del usuario, todo lo demás se mantiene igual. Accedemos y, una vez que nos pida la contraseña y pegamos la que habíamos guardado anteriormente en nuestro portapapeles.\nLas instrucciones para el siguiente nivel son las siguientes.\nNos especifica que la contraseña está guardada en un archivo localizado en el directorio home con el nombre \u0026lsquo;-\u0026rsquo;.\nEl desafío parece simple, pero el problema surge cuando escribimos el comando cat -. Este se queda en espera, ya que lo toma como si fuera un parámetro de cat. Entonces, ¿cómo solucionamos esto? Para poder resolver este desafío, podemos hacerlo de varias formas:\nDesde la ruta absoluta: cat /home/bandit1/-. De esta forma, indicamos la ruta completa del archivo, evitando que cat lo confunda con un parámetro.\nForma alternativa: cat $(pwd)/-. Usando este método, nos ahorramos escribir toda la ruta. El comando pwd nos da la ruta actual, y usamos esa salida para que cat interprete correctamente la ubicación del archivo. Esto se especifica usando los símbolos $().\nIndicando la ruta actual: cat ./-. De esta forma, indicamos que desde la ruta actual en la que nos encontramos (representada por un punto), y se lee el archivo con el nombre \u0026ldquo;-\u0026rdquo;.\nObservamos que, de cualquiera de estas maneras, obtenemos la contraseña.\nAqui conluimos con este nivel, nos salimos y accedemos al siguiente.\nLevel 2 -\u0026gt; level 3 Para este nivel, observamos que hay un archivo llamado \u0026ldquo;spaces in this filename\u0026rdquo;. Para poder leer este tipo de archivos con espacios, necesitamos escapar cada espacio con el carácter especial barra inversa \\, quedando así el comando: cat spaces\\ in\\ this\\ filename. De igual forma, podemos ahorrarnos esto usando la tecla tab, la cual nos autocompleta lo mencionado anteriormente.\nOtra forma de hacer este proceso es usando comillas dobles, quedando de esta manera: cat \u0026quot;spaces in this filename\u0026quot;. De esta forma, le indicamos el nombre del archivo.\nPero además de hacer eso, también podemos ahorrarnos escribir el nombre. Para hacer esto más rápido, hacemos uso del carácter especial asterisco *, el cual interpreta cualquier cosa, quedando así el comando: cat *filename. De esta forma, le indicamos que queremos leer todos los archivos que terminen en \u0026ldquo;filename\u0026rdquo;. Igualmente, se puede modificar el orden del asterisco, por ejemplo: cat spaces*, aquí se indica que queremos leer todos los archivos que comiencen con el nombre \u0026ldquo;spaces\u0026rdquo;. Cabe aclarar que este comando es mejor usarlo cuando sabemos que solo existe un archivo con ese nombre; en caso contrario, listará el contenido de todos los archivos que encuentre.\nAhora que tenemos la contraseña nos dirigimos al siguiente nivel.\nLevel 3 -\u0026gt; Level 4 Para este nivel la contraseña esta guardada en un archivo oculto dentro del directorio \u0026ldquo;inhere\u0026rdquo;\nEste nivel es muy simple, si listamos el contenido de la carpeta con el comando ls, sabremos que a simple vista nos e ve nada, para ello vamos a hacer uso de los parametros de dicho comando, usaremos el parametro -a para listar todo lo que se encuentre a dentro quedando asi el comando: ls -a inhere. Y ahora podemos observar que hay un archivo con el nombre \u0026ldquo;\u0026hellip;Hiding-From-You\u0026rdquo;, con el comando cat revisamos el contenido y tendremos la contraseña.\nLevel 4 -\u0026gt; level 5 Para este nivel, se nos indica que la contraseña está guardada en un archivo humanamente legible, dentro del directorio \u0026ldquo;inhere\u0026rdquo;.\nSi listamos el contenido del directorio, podemos notar que hay múltiples archivos con distintos nombres. Dado que no todos tienen contenido legible y para evitar abrir e inspeccionar uno por uno, vamos a identificar el archivo correcto con los comandos file y find.\nEl comando file nos permite saber la clasificación de cada archivo: si es una imagen, un archivo de texto, un binario, un video, etc. El comando find es una alternativa al comando ls, con la diferencia de que find busca desde la raíz de la ruta que se le pase. Por ejemplo, si escribimos el comando find inhere, este nos listará el contenido en forma de lista usando un formato de árbol binario.\nLo que vamos a hacer a continuación es combinar los comandos find y file. ¿Y cómo hacemos eso? Fácil, con el comando xargs y el uso del carácter \u0026ldquo;pipe\u0026rdquo; |.\nEl comando xargs lee los argumentos desde la entrada estándar. Por ejemplo, si nosotros escribimos el siguiente comando:\necho \u0026quot;file1.txt file2.txt file3.txt\u0026quot; | xargs touch\nEsto creará los archivos file1.txt, file2.txt, y file3.txt\nLo que estamos haciendo es lo siguiente: dada la salida del comando echo, queremos crear archivos con el nombre de dicha salida. Entonces, se ejecuta xargs touch y el resultado es que se crean tres archivos con los nombres file1.txt, file2.txt, etc.\nUsando el carácter \u0026ldquo;or/pipe\u0026rdquo; |, que es un carácter especial, se puede hacer que la salida de un comando sea la entrada de otro comando.\nBien, una vez explicado esto, utilizamos lo que sabemos con el comando find. Vamos a ejecutar la siguiente instrucción: find . | xargs file. Usamos el punto . en el comando find para especificar que queremos que busque archivos desde la ruta en la que estamos.\nSi seguimos los pasos hasta aquí, ya tendremos listados todos los archivos y notamos que hay uno que es de tipo ASCII. Es el único dentro del directorio inhere. Por lo tanto, abrimos ese archivo con el comando cat y observamos que contiene la contraseña para el siguiente nivel.\nLevel 5 -\u0026gt; 6 Para este nivel, las instrucciones mencionan que el archivo que guarda la contraseña está en algún lugar dentro del directorio \u0026ldquo;inhere\u0026rdquo; y tiene las siguientes propiedades:\nEs humanamente legible.\nTiene un tamaño de 1033 bytes.\nNo es un archivo ejecutable.\nVamos a usar el comando find, ya que este comando tiene parámetros que nos pueden ayudar a encontrar el archivo siguiendo estas propiedades.\nEl comando que vamos a utilizar es el siguiente:\nfind inhere/ -readable -size 1033c ! -executable.\nEl parámetro -readable busca un archivo que sea legible. Con el parámetro -size especificamos que sea de un determinado tamaño; puede ser en megas, gigas, etc., pero en esta ocasión es en bytes, por lo tanto, se usa la letra \u0026lsquo;c\u0026rsquo;. El carácter ! es para negar una condición, así que especificamos que no queremos que sea ejecutable. Si quitamos el signo de exclamación, le estamos indicando que queremos que sea ejecutable.\nAl ejecutar el comando, podemos ver que nos da un output de un archivo en la carpeta \u0026ldquo;maybehere07\u0026rdquo;, dentro del archivo \u0026ldquo;.file2\u0026rdquo;. Entonces, tenemos varias formas de leer este archivo.\nUsando cat como lo haría un chad promedio, el comando es el siguiente:\ncat $(find inhere/ -readable -size 1033c ! -executable)\nUsando cat de manera normal, el siguiente comando seria este:\ncat inhere/maybehere07/.file2\nAmbas maneras nos daran la contraseña, de igual manera puedes seguir buscando para tener un formato mas limpio con el comando xargs, como se ve a continuacion.\nUna vez obtuvimos la contraseña nos vamos para el siguiente nivel.\nHWasnPhtq9AVKe0dmk45nxy20cvUa6EG\nLevel 6 -\u0026gt; 7 En construccion . . .\n","date":"2024-01-10T00:00:00Z","image":"http://localhost:1313/p/comandos-basicos-en-linux-parte-1/wallpaper_hua39c6827143249c74e927fd9c967d9eb_10021_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/comandos-basicos-en-linux-parte-1/","title":"Comandos Basicos en Linux - Parte 1"},{"content":" Bienvenid@s a mi blog! Un pequeño rincón de la Informática, programacion y ciberseguridad\n¡Hola a todos!\nBienvenidos a mi blog sobre ciberseguridad y programación en C++, Python y Bash. Mi nombre es Gerardo Hernandez Gomez.\nSoy un apasionado de la programación y la ciberseguridad. Desde hace unos años, he estado explorando el mundo de la informática, y a lo largo de los años, he adquirido habilidades en programación y me entusiasma compartir mi conocimiento y experiencias contigo a través de este blog.\nSobre el Blog Este blog nació de mi interés por dos campos apasionantes: Ciberseguridad y la programación. Aquí, encontrarán una variedad de contenido relacionado con estos temas, diseñados para ayudar a principiantes y entusiastas experimentados por igual. Algunos de los tipos de contenido que pueden esperar incluyen:\nArtículos sobre Ciberseguridad: Exploraré las últimas tendencias en seguridad informática y ofreceré consejos prácticos para protegerse en línea. Además, analizaré casos de estudio sobre ciberataques y compartiré ejemplos de intrusiones utilizando plataformas de formación en ciberseguridad como Hack The Box y TryHackMe. A medida que sigo aprendiendo y experimentando en este campo, compartiré mis hallazgos contigo. Programación en C++, Python y Bash: Publicaré tutoriales, consejos y trucos sobre programación en estos lenguajes, desde los conceptos básicos hasta proyectos más avanzados. Como alguien que también está en constante aprendizaje, te invito a crecer junto conmigo en el mundo de la programación. Herramientas y Recursos: Compartiré herramientas útiles, recursos gratuitos y enlaces a sitios web y libros relacionados con la ciberseguridad y la programación. Estoy convencido de que el acceso a recursos de calidad puede hacer que tu viaje de aprendizaje sea más eficiente y emocionante. Experiencias Personales: De vez en cuando, compartiré mis propias experiencias y desafíos en el mundo de la informática, con la esperanza de inspirar y ayudar a otros. Puedes esperar escuchar sobre mis proyectos personales y lo que he aprendido a lo largo del camino. Mi Motivación La razón detrás de la creación de este blog es simple: quiero fomentar la educación, la conciencia y la comunidad en los campos de la ciberseguridad y la programación. Creo firmemente que el conocimiento debe ser compartido y que todos, sin importar su nivel de habilidad, pueden beneficiarse de aprender sobre estos temas fascinantes.\nÚnanse a la Comunidad Estoy emocionado de embarcarme en este viaje contigo. Si eres un entusiasta de la ciberseguridad, un aprendiz de la programación o simplemente tienes curiosidad por estos temas, este es el lugar adecuado.\n¡Los invito a unirse a nuestra comunidad, seguirme en las redes sociales para estar al tanto de las actualizaciones y participar en la conversación!\nConclusion Muchas gracias por visitar mi blog y por tomar el tiempo de leer este primer post. Espero que encuentres contenido valioso y que disfrutes de tu estadía aquí a medida que voy subiendo contenido.\nSi tienes alguna pregunta, sugerencia o un tema específico que te gustaría que cubra, no dudes en ponerse en contacto conmigo. Estoy ansioso por interactuar contigo y compartir nuestro entusiasmo por el conocimiento en la tecnologia!.\n¡Hasta la próxima publicación! ","date":"2023-11-05T12:51:10-05:00","permalink":"http://localhost:1313/p/bienvenida/","title":"Bienvenida"}]